---
phase: 03-core-map
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/parquet.ts
  - frontend/src/style.ts
  - frontend/src/bee-map.ts
autonomous: true
requirements:
  - MAP-01

must_haves:
  truths:
    - "Specimen points cluster visually at low zoom levels — numbered circles replace individual dots"
    - "Zooming in splits clusters into smaller clusters and individual points"
    - "Each cluster displays its specimen count as text inside the circle"
    - "Cluster color reflects recency of the most recent specimen (3 tiers: green/orange/grey)"
    - "Individual specimen points (cluster of 1) use the same recency color scheme at fixed small radius"
  artifacts:
    - path: "frontend/src/parquet.ts"
      provides: "ParquetSource reading all sidebar and style columns"
      contains: "year, month, scientificName, recordedBy, fieldNumber, genus, family"
    - path: "frontend/src/style.ts"
      provides: "clusterStyle function with recency colors and RECENCY_COLORS constant object"
      exports: ["clusterStyle", "RECENCY_COLORS"]
    - path: "frontend/src/bee-map.ts"
      provides: "VectorLayer using ol/source/Cluster wrapping specimenSource"
      contains: "Cluster"
  key_links:
    - from: "frontend/src/bee-map.ts"
      to: "frontend/src/style.ts"
      via: "clusterStyle passed to VectorLayer style option"
      pattern: "clusterStyle"
    - from: "frontend/src/style.ts"
      to: "temporal-polyfill"
      via: "Temporal.Now.plainDateISO() and PlainDate.compare()"
      pattern: "Temporal\\.Now\\.plainDateISO"
    - from: "frontend/src/bee-map.ts"
      to: "ol/source/Cluster"
      via: "clusterSource wrapping specimenSource"
      pattern: "new Cluster"
---

<objective>
Wire ol/source/Cluster to the existing map and replace the static beeStyle with a recency-aware cluster style function.

Purpose: MAP-01 — specimen points must cluster at low zoom levels with size encoding count and color encoding recency.
Output: Updated parquet.ts (expanded columns), rewritten style.ts (clusterStyle with recency), updated bee-map.ts (Cluster source on layer).
</objective>

<execution_context>
@/Users/rainhead/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rainhead/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-map/03-CONTEXT.md
@.planning/phases/03-core-map/03-RESEARCH.md
@frontend/src/bee-map.ts
@frontend/src/parquet.ts
@frontend/src/style.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expand Parquet columns</name>
  <files>frontend/src/parquet.ts</files>
  <action>
Update `parquet.ts` to read all columns needed for the cluster style and sidebar. The current `columns` array reads only `['ecdysis_id', 'ecdysis_fieldNumber', 'longitude', 'latitude']`. Replace it with:

```typescript
const columns = [
  'ecdysis_id',
  'longitude',
  'latitude',
  'year',
  'month',
  'scientificName',
  'recordedBy',
  'fieldNumber',
  'genus',
  'family',
];
```

Note: `ecdysis_fieldNumber` was the old prefixed column name. The pipeline writes `fieldNumber` (no prefix) — use `fieldNumber` directly.

In the `objects.map()` loader callback, after setting geometry and ID, call `feature.setProperties()` with all the non-geometry fields:

```typescript
feature.setProperties({
  year: obj.year,
  month: obj.month,
  scientificName: obj.scientificName,
  recordedBy: obj.recordedBy,
  fieldNumber: obj.fieldNumber,
  genus: obj.genus,
  family: obj.family,
});
```

Remove the old `ecdysis_fieldNumber` reference entirely. Keep `feature.setId('ecdysis:' + obj.ecdysis_id)`.
  </action>
  <verify>
TypeScript compiles without errors: `cd /Users/rainhead/dev/beeatlas/frontend && npx tsc --noEmit`
  </verify>
  <done>parquet.ts compiles cleanly, columns array includes year/month/scientificName/recordedBy/fieldNumber/genus/family, feature.setProperties stores all non-geometry fields.</done>
</task>

<task type="auto">
  <name>Task 2: Rewrite clusterStyle with recency tiers</name>
  <files>frontend/src/style.ts</files>
  <action>
Replace the contents of `style.ts` with a recency-aware cluster style function. Remove the old `beeStyle` export (it will be replaced by `clusterStyle` in bee-map.ts). Keep `clusterStyle` as the exported style function.

Key implementation requirements from CONTEXT.md and RESEARCH.md:

1. **RECENCY_COLORS constant** — export it so it is easy to revise later:
```typescript
export const RECENCY_COLORS = {
  fresh:    '#2ecc71',  // within 6 weeks
  thisYear: '#f39c12',  // this year, older than 6 weeks
  older:    '#7f8c8d',  // before this year
} as const;
```

2. **Recency computation** — computed once at module load time (not per render):
```typescript
import { Temporal } from 'temporal-polyfill';
const today = Temporal.Now.plainDateISO();
const sixWeeksAgo = today.subtract({ weeks: 6 });

function recencyTier(year: number, month: number): keyof typeof RECENCY_COLORS {
  const sampleDate = Temporal.PlainDate.from({ year, month, day: 1 });
  if (Temporal.PlainDate.compare(sampleDate, sixWeeksAgo) >= 0) return 'fresh';
  if (year >= today.year) return 'thisYear';
  return 'older';
}
```

3. **Style cache** — cache by `${count}:${tier}` to avoid object allocation on every render:
```typescript
const styleCache = new Map<string, Style>();
```

4. **clusterStyle function** — reads `feature.get('features')` (the inner array from Cluster source). CRITICAL: data lives on inner features, NOT on the cluster feature itself. Always unwrap via `feature.get('features')`:
```typescript
export function clusterStyle(feature: Feature): Style {
  const innerFeatures: Feature[] = feature.get('features') ?? [feature];
  const count = innerFeatures.length;

  // Find the most-recent tier across all inner features
  let bestTier: keyof typeof RECENCY_COLORS = 'older';
  for (const f of innerFeatures) {
    const tier = recencyTier(f.get('year') as number, f.get('month') as number);
    if (tier === 'fresh') { bestTier = 'fresh'; break; }
    if (tier === 'thisYear') bestTier = 'thisYear';
  }

  const cacheKey = `${count}:${bestTier}`;
  if (styleCache.has(cacheKey)) return styleCache.get(cacheKey)!;

  const radius = count === 1 ? 4 : 6 + Math.log2(count) * 2;
  const color = RECENCY_COLORS[bestTier];

  const style = new Style({
    image: new Circle({
      radius,
      fill: new Fill({ color }),
      stroke: new Stroke({ color: '#fff', width: 1 }),
    }),
    text: new Text({
      text: String(count),
      fill: new Fill({ color: '#fff' }),
      font: 'bold 11px sans-serif',
    }),
  });
  styleCache.set(cacheKey, style);
  return style;
}
```

Required imports: `Circle`, `Fill`, `Stroke`, `Style`, `Text` from `ol/style/*.js`; `Feature` from `ol`; `Temporal` from `temporal-polyfill`.

Remove the old `beeStyle` export and `clusterStyle` arrow function. The `Feature` parameter type (not `RenderFeature`) is correct here since we access `.get()` on inner features too.
  </action>
  <verify>
TypeScript compiles without errors: `cd /Users/rainhead/dev/beeatlas/frontend && npx tsc --noEmit`
  </verify>
  <done>style.ts exports clusterStyle (function, not arrow with RenderFeature) and RECENCY_COLORS; beeStyle removed; style cache present; recency tiers computed once at module load.</done>
</task>

<task type="auto">
  <name>Task 3: Wire Cluster source to VectorLayer in bee-map.ts</name>
  <files>frontend/src/bee-map.ts</files>
  <action>
Update `bee-map.ts` to use `ol/source/Cluster` wrapping `specimenSource`, and use the new `clusterStyle` function.

Changes:

1. Add import:
```typescript
import Cluster from 'ol/source/Cluster.js';
```

2. Replace the import of `beeStyle` with `clusterStyle`:
```typescript
import { clusterStyle } from './style.ts';
```

3. After `specimenSource` is defined, create the cluster source:
```typescript
const clusterSource = new Cluster({
  distance: 40,
  minDistance: 0,
  source: specimenSource,
});
```

4. Update `speicmenLayer` (preserve the existing typo in the variable name to avoid unrelated churn) to use `clusterSource` and `clusterStyle`:
```typescript
const speicmenLayer = new VectorLayer({
  source: clusterSource,
  style: clusterStyle,
});
```

No other changes to `bee-map.ts` in this plan — the click handler and layout are added in plan 02.

Remove the `LayerGroup` import if it is only used for the now-empty `baseLayer` (check first — if `baseLayer` is still used in the layers array, leave LayerGroup).
  </action>
  <verify>
TypeScript compiles without errors: `cd /Users/rainhead/dev/beeatlas/frontend && npx tsc --noEmit`

Then do a quick visual smoke test: `cd /Users/rainhead/dev/beeatlas/frontend && npm run dev` — open http://localhost:5173, zoom out to see all of Washington. Clusters should appear as colored numbered circles. Individual points at high zoom should be small colored dots.
  </verify>
  <done>bee-map.ts imports Cluster from ol/source/Cluster.js; clusterSource wraps specimenSource with distance:40; VectorLayer uses clusterSource and clusterStyle; TypeScript compiles cleanly; visual smoke test shows clustered numbered circles on the map.</done>
</task>

</tasks>

<verification>
After all three tasks:
1. `cd /Users/rainhead/dev/beeatlas/frontend && npx tsc --noEmit` — zero TypeScript errors
2. `npm run build` completes without errors
3. `npm run dev` — map shows clustered numbered circles at low zoom, individual points at high zoom
4. Cluster circles are colored (green/orange/grey) and display the specimen count
</verification>

<success_criteria>
- MAP-01: ol/source/Cluster is wired on the specimen layer (verified by Cluster import in bee-map.ts and visual clustering behavior)
- Parquet reads year/month/scientificName/recordedBy/fieldNumber/genus/family columns
- clusterStyle encodes count in circle radius and recency in circle color
- RECENCY_COLORS exported as a named constant for easy future revision
- Style objects cached by (count, tier) key
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-map/03-01-SUMMARY.md` capturing:
- Files modified and key changes made
- The clusterStyle cache key format used
- The Parquet columns array (final list)
- Any deviations from the plan and why
- TypeScript compile status
</output>
